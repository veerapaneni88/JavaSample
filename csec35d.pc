/***************************************************************************
**
** Module File:  CSEC35D.PC
** 
** DAM Name:     CSEC35D
** 
** Description:  This DAM will retrieve a full row from the Name table.
** 
** Environment:  HP-UX v9.04
**               FOUNDATION 2.4 for Unix (Construction, Production)
**               HP-UX Ansi C Compiler
**               ORACLE Pro*C SQL PreCompiler
** 
** Date Created: Fri Oct 13 11:31:14 1995
**
** Programmer:   Jennifer Howell
**
** Archive Information: $Revision:   1.0  $
**                      $Date:   27 May 1996 20:39:02  $
**                      $Modtime:   28 Mar 1996 20:26:44  $
**                      $Author:   pvcs  $
**
** Change History:
**  Date      User      Description
**  --------  --------  --------------------------------------------------
**
***************************************************************************/ 

/**************************************************************************
** Include Files
***************************************************************************/
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>
#include <float.h>
#include <kglhk020.h>
#include <kcdak010.h>
#include "arcsrvr.h"

#include "csec35di.h"
#include "csec35do.h"

EXEC SQL INCLUDE sqlca.h;

/*************************************************************************
*
*          Function:        csec35dQUERYdam
*
*
*              File:        CSEC35D.PC
*
*
*        Generation:        Fri Oct 13 11:31:14 1995
*
*************************************************************************/
long  csec35dQUERYdam(void *pSQLCA,
                          _CSEC35DI *pInputDataRec,
                          _CSEC35DO *pOutputDataRec) 
{

EXEC SQL BEGIN DECLARE SECTION;
unsigned long hI_ulIdPerson;
short hI_ulIdPerson_i;

unsigned long hO_ulIdName;
short hO_ulIdName_i;
char hO_tsLastUpdate[7];
EXEC SQL VAR hO_tsLastUpdate IS DATE;
short hO_tsLastUpdate_i;
unsigned long hO_ulIdPerson;
short hO_ulIdPerson_i;
char hO_bIndNameInvalid;
EXEC SQL VAR hO_bIndNameInvalid IS CHAR(1);
short hO_bIndNameInvalid_i;
char hO_szNmNameFirst[13];
EXEC SQL VAR hO_szNmNameFirst IS STRING;
short hO_szNmNameFirst_i;
char hO_szNmNameMiddle[13];
EXEC SQL VAR hO_szNmNameMiddle IS STRING;
short hO_szNmNameMiddle_i;
char hO_szNmNameLast[23];
EXEC SQL VAR hO_szNmNameLast IS STRING;
short hO_szNmNameLast_i;
char hO_bIndNamePrimary;
EXEC SQL VAR hO_bIndNamePrimary IS CHAR(1);
short hO_bIndNamePrimary_i;
char hO_szCdNameSuffix[3];
EXEC SQL VAR hO_szCdNameSuffix IS STRING;
short hO_szCdNameSuffix_i;
char hO_dtDtNameStartDate[7];
EXEC SQL VAR hO_dtDtNameStartDate IS DATE;
short hO_dtDtNameStartDate_i;
char hO_dtDtNameEndDate[7];
EXEC SQL VAR hO_dtDtNameEndDate IS DATE;
short hO_dtDtNameEndDate_i;
EXEC SQL END DECLARE SECTION;

long BegPageRow = 0, EndPageRow = 0, i = 0;
long lTotal = 0, lOutputIndex = 0, lHostIndex = 0;
unsigned short uStatus;
struct sqlca previousSQLCA;
sqlca.sqlcode = 0;

uStatus=ARC_UTLNumberToHost(&hI_ulIdPerson,
             &(pInputDataRec->ulIdPerson),
             sizeof(pInputDataRec->ulIdPerson),
             &hI_ulIdPerson_i);
if (uStatus != 0)
{
    return (uStatus);
}




EXEC SQL
	DECLARE CSEC35D_CURSOR CURSOR FOR
	SELECT
		N.ID_NAME,
		N.DT_LAST_UPDATE,
		N.ID_PERSON,
		N.IND_NAME_INVALID,
		N.NM_NAME_FIRST,
		N.NM_NAME_MIDDLE,
		N.NM_NAME_LAST,
		N.IND_NAME_PRIMARY,
		N.CD_NAME_SUFFIX,
		N.DT_NAME_START_DATE,
		N.DT_NAME_END_DATE
	FROM NAME N
	WHERE ID_PERSON = :hI_ulIdPerson:hI_ulIdPerson_i
	AND     IND_NAME_PRIMARY  = 'Y'
        AND     DT_NAME_END_DATE  = '12/31/4712';

/*****************************/
/* Total selected fields: 11 */
/*****************************/

EXEC SQL
	OPEN CSEC35D_CURSOR;


if ( sqlca.sqlcode != 0 )
{
	memcpy(pSQLCA, (void *)&sqlca, sizeof(struct sqlca));
	return sqlca.sqlcode;
}


EXEC SQL
	FETCH CSEC35D_CURSOR INTO
		:hO_ulIdName:hO_ulIdName_i,
		:hO_tsLastUpdate:hO_tsLastUpdate_i,
		:hO_ulIdPerson:hO_ulIdPerson_i,
		:hO_bIndNameInvalid:hO_bIndNameInvalid_i,
		:hO_szNmNameFirst:hO_szNmNameFirst_i,
		:hO_szNmNameMiddle:hO_szNmNameMiddle_i,
		:hO_szNmNameLast:hO_szNmNameLast_i,
		:hO_bIndNamePrimary:hO_bIndNamePrimary_i,
		:hO_szCdNameSuffix:hO_szCdNameSuffix_i,
		:hO_dtDtNameStartDate:hO_dtDtNameStartDate_i,
		:hO_dtDtNameEndDate:hO_dtDtNameEndDate_i;

/**************************/
/* Total fetch fields: 11 */
/**************************/


memcpy (&previousSQLCA, &sqlca, sizeof (struct sqlca));

if ( sqlca.sqlcode == 0 )
{
             uStatus=ARC_UTLHostToNumber(&(pOutputDataRec->ulIdName),
                          &hO_ulIdName,
                          sizeof(hO_ulIdName),
                          hO_ulIdName_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToTimestamp(pOutputDataRec->tsLastUpdate,
                          hO_tsLastUpdate,
                          hO_tsLastUpdate_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToNumber(&(pOutputDataRec->ulIdPerson),
                          &hO_ulIdPerson,
                          sizeof(hO_ulIdPerson),
                          hO_ulIdPerson_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToNumber(&(pOutputDataRec->bIndNameInvalid),
                          &hO_bIndNameInvalid,
                          sizeof(hO_bIndNameInvalid),
                          hO_bIndNameInvalid_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToString(pOutputDataRec->szNmNameFirst,
                          hO_szNmNameFirst,
                          13,
                          hO_szNmNameFirst_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToString(pOutputDataRec->szNmNameMiddle,
                          hO_szNmNameMiddle,
                          13,
                          hO_szNmNameMiddle_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToString(pOutputDataRec->szNmNameLast,
                          hO_szNmNameLast,
                          23,
                          hO_szNmNameLast_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToNumber(&(pOutputDataRec->bIndNamePrimary),
                          &hO_bIndNamePrimary,
                          sizeof(hO_bIndNamePrimary),
                          hO_bIndNamePrimary_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToString(pOutputDataRec->szCdNameSuffix,
                          hO_szCdNameSuffix,
                          3,
                          hO_szCdNameSuffix_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToDateAndTime(&(pOutputDataRec->dtDtNameStartDate),
                          pOutputDataRec->tmScrTmGeneric1,
                          hO_dtDtNameStartDate,
                          hO_dtDtNameStartDate_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

             uStatus=ARC_UTLHostToDateAndTime(&(pOutputDataRec->dtDtNameEndDate),
                          pOutputDataRec->tmScrTmGeneric2,
                          hO_dtDtNameEndDate,
                          hO_dtDtNameEndDate_i);
             if (uStatus != 0)
             {
                 return (uStatus);
             }

}


EXEC SQL
	CLOSE CSEC35D_CURSOR;


memcpy (pSQLCA, &previousSQLCA, sizeof(struct sqlca));
return (((struct sqlca *)pSQLCA)->sqlcode);
}
